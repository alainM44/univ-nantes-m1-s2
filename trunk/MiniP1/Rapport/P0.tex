%\chapter{Cas concret : Tas binaire}
\chapter[Concrète]{Choix de la structure concrète%
\chaptermark{Concrète}}
\chapternmark{Concrète}


Nous avons recherché la structure concrète la plus performante dans l'ensemble des opérations. Ne pouvant savoir quelle serait la nature de l'utilisation de cette classe, la structure ayant les une moyenne des performance la plus forte sur l'ensemble des candidates, semblait un bon compromis.
Plusieurs solutions se présentaient pour une implémentation de tas binaire :
\begin{description}
\item
[Tableau des pères] Non approprié (dédié aux arborescence non-ordonnées).
\item[Une liste d'adjacence] Un noeud étant un élément  (étiquette, père, liste des fils) de la liste. Ses perfomances sont dégradées lors d'opération comme la supression ($O(n)$ pour un tas binaire ) ou l'accès à un noeud à partir de son étiquette ($O(n)$). Dans le cas d'une utilisation où les opérations principales aurait été l'ajout d'un fils par exemple, cette solution aurait pu être retenue.
\item[Liste de fratrie]  Un noeud étant un élément (étiquette, père, liste des frères, premier fils)  de la liste.
\item[Tableau modulaire]
\textbf{definition manquante} Structure présentant les meilleurs compléxités pour l'ensemble des opérations. Cette solution répond le mieux aux contraintes que nous avons exposés précedement. C'est donc elle que nous avons retenue. 
\end{description} 


\section[Developpement]{Developpement du tas binaire%
\sectionmark{Developpement}}
\sectionmark{Developpement}

%\section{Developpement du tas binaire}
Une fois la selection de la structure faite. Nous avons au cours des semaines adopté le plan de developpement suivant : 
\begin{enumerate}
\item
Définition des prototypes des méthodes
\item
Implémentation des méthodes
\item
Rajout de l'itérateur 
\item
Rajout de l'allocateur et du comparator
\item
Debug
\end{enumerate}
Cette démarche nous a permis d'avancer rapidément au cours des première semaine. Les cours d'algorithmiques du 1\up{er} semestre encore en tête. Nous avons rapidement déployées les méthodes principales du tas binaire (Extraire, Tasser, Insérer\dots), sans trop nous soucier de la syntaxe C++ (nouvelle pour notre bînome). Nous avons amèrement regretté notre insoucience de ne jamais tester nos méthodes avant la 5\up{ème} ou 6\up{ème} semaine. Nous avons passé un temps très long à débuguer un nombre de d'erreurs de syntaxe conséquent. 

