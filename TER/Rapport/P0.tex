\chapter{Étude des structures de données}


%nombre de caractéristiques ?? de quels type 

%Regarder JDK allocation d'une boite structure


%lister toutes les possibilité - garder toutes les structures - reconstruire l'arbre.. refaire une passe sur le fichier

%Comparaison arraylist tree map

%correspondance id var : x est la variable numéro 4..

%stockage des caractéristiques: 3map(id var ref) dans chque boite ? une map globale

\section{Introduction}
L'objectif de ce document est de mener une études sur les différentes structures de données nécessaires aux futurs algorithmes de visualisation. Les calculs de compléxité seront réalisés selon le paramètre $n$  représentant le nombre de boîtes, et $d$ est le nombre de dimensions du problème. Le nombre de boîtes réelement utilisée dans le pavage est représenté par N.\textbf{Vérifier pour N}


\section{Définition de la boîte}
C'est l'entité du pavage. Les accès à ses attributs sont donc cruciaux. On rappelle qu'une boîte est définie de la manière suivante : 
\begin{itemize}
 \item 
Un identifiant : Une \verb+String+ respectant un format précis (c.f 1.1 du document de spécifications).
\item
Une liste de coordonnées. Une liste de type \verb+Interval+.
\item
Une liste des caractéristiques, dans l'ordre et selon les types définis en entête
\end{itemize}
Ces données seront régulièrement requises durant les algorithmes nécessaires à la visualisation. Il est donc important que leurs accès soient rapides, voir direct. Pour le cas de l'identifiant, s'agissant d'une simple string le problème de la structure à utiliser ne se pose pas. Pour la liste des coordonnées en revanche, il s'agit d'une séquence finie de données. Plusieurs possibilités sont alors envisageable : 

\begin{itemize}
 \item
Un tableau : L'accès à une coordonnée serait direct. Les opérations d'ajout et de suppression sont revanches coûteuses. Or il est peu probable que ce type d'opération intervienne.
\item
Une liste : Si l'accès à une coordonnée ne serait pas direct, les opérations d'ajouts de de suppressions sont en temps constant. Ces caractéristiques ne conviennent pas à notre problème.
\item
Une hashmap : Coûteuse si la fonction de hashage n'est pas appropriée, la HashMap propose cependant un accès direct. Cependant même pour un petit nombre d'éléments, son occupation mémoire peut être conséquente. 
\end{itemize}
L'étude ci-dessus des trois structures de données, oriente notre choix vers le tableau. Or une alternative serait une TreeMap \cite{TreeMap}. 
%http://docs.oracle.com/javase/1.4.2/docs/api/java/util/TreeMap.html
Implémentation de base des arbres rouges noirs, cette map a la particularité de posséder des clefs triées. Ainsi les complexités de plusieurs opérations telle que l'accès en $\log{n}$. Dans le cas d'un grand nombre de valeurs à stocker, il est plus performant de construire la TreeMap à partir d'une HashMap.

La création d'une boîte a alors une complexité en $O(d)$. De plus l'accès aux différents attributs de la boîte (identifiant, liste des coordonnées) sera en $O(1)$.

\subsection{Variables et identifiants}
Il est nécessaire de faire le lien de manière efficace entre le nom d'une variable, et sa place dans la structure. En effet comment savoir que la valeur \verb+x+ se trouve à la position 4 dans la structure de donnée.
\begin{itemize}
\item
Selon le document de spécifications, les variables sont données dans un ordre précis, donné dans l'entête du fichier d'entrée. On peut alors utiliser une map «gobale» renseignant la position de chaque variable. Ci cette méthode permet de gagner de l'espace mémoire au sein d'une boîte, le nombre d'accès à cette map risque d'être élevé.
\item
Utiliser une TreeMap (la clef étant le nom de la variable).
\end{itemize} 

\subsection{Généricité des caractéristiques}
Un problème majeur apparaît pour l'instanciation des boîtes. Elles ont en effet chacune un nombre de caractéristiques potentiellement différents. De plus, on rappelle qu'une caractéristique a plusieurs types. Plusieurs solutions sont envisageables : 
\begin{itemize}
 \item 
Chaque boîte possède trois maps pour ces trois types de caractéristiques. Cette solution à l'inconveinient d'être coûteuse si par exemple une bôite ne possède que des caractéristiques de type \verb+String+ et aucunes de types \verb+Number+ ou \verb+Interval+. 
 \item
Seulement une map contenant des \verb+String+ stocke les différentes caractéristiques de la boîte. On aura caster les attributs \verb+Number+ ou \verb+Interval+ en \verb+String+.
\item \huge{IL MANQUE UN CAS}
\end{itemize}


\section{Stockage du pavage}
L'outil de visualisation peut charger un fichier entrée de manière dynamique ou non. Nous nous plaçons ici dans le cadre où cette option de chargement dynamique n'est pas activée. \\ L'outil va lire donc de façon séquentielle chaque ligne du fichier d'entrée. 
% Le création de structure de  données peut alors se faire de différentes  manières : 
% Chaque boîte est crée de manière séquentielle selon l'ordre du fichier puis stockée dans la structure de donnée. Le trie de la structure aura lieu plus tard ., 
Le nombre potentiellement très grand de boîtes éliminent d'emblée la possibilité de choisir  une table de hashage. En effet même si la fonction de hashage est judicieusement choisie, l'occupation mémoire requise serait bien trop importante. Les listes sont pas appropriées ici. Une complexité en $n²$ pour un accès à une boîte n'est pas raisonnable. Les arbres ont l'atout de pouvoir stocker et manipuler un grand nombre de d'entités. Les arbres de recherches sont des arborescences ordonnées permettant un accès en $\log(n)$. Dans le cas où la structure serait triée au fur et à mesure de sa construction. Les arbres de recherche proposent de bonnes performances.



\paragraph{Arbre binaire}
Par exemple l'utilisation d'un arbre binaire de recherche pour la création de n boîtes aurait une complexité de $n²$ en pire cas. En effet il s'agit du cas où les boîtes arriveraient triées selon l'ordre inverse de celui que l'on souhaite. Il faudrait alors effecter $(p-1)$ comparaisons, pour chaque boîte :  $\sum_{p=2}^{n}(p-1)$  Soit $O(n)=\frac{1}{2}n²-\frac{1}{2}n$. Cependant dans le meilleur des cas cette opération a une complexité en $n\log{n}$.
La création d'un pavage composé de n boîtes à d dimensions aurait alors une complexité égale à: $(n*d)*n\log(n)$ $\triangle$
%http://www.enseignement.polytechnique.fr/profs/informatique/Luc.Maranget/421/poly/arbre-bin.html
\clearpage
\paragraph{Arbres a-b}
Il s'agit d'un arbre de recherche avec les propriétés suivantes :
\begin{itemize}
\item
$a\leq2$ et $b\leq 2a−1$ deux entiers
\item
La racine a au moins 2 fils (sauf si l'arbre ne possède qu'un noeud) et au plus b fils,
\item 
Les feuilles sont de même profondeur,
\item
les autres nœuds internes ont au moins a et au plus b fils
\end{itemize}

\begin{figure}[htbp]
  \centering
  \includegraphics[scale=0.40]{img/abtree}
  \caption{a-b tree}
  \label{fig:dnuages}
\end{figure}


L'avantage des arbres a-b est que leurs hauteurs sont sont comprises entres les valeurs suivantes : $ \dfrac{\log{n}}{\log{b}}   \leq h  < 1 + \dfrac{\log{n/2}}{\log{a}}$. Ainsi les opération d'insertions ne serait plus en $n\log{n}$ mais en $\log{n}$.

La création d'un pavage composé de n boîtes à d dimensions aurait alors une complexité égale à: $(n*d)*\log(n)$ $\triangle$
